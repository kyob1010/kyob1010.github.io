<html>
  <head>
  <title>Learning WebGL &mdash; lesson 1</title>
  <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
  <script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
  <script id="shader-fs" type="x-shader/x-fragment">
  precision mediump float;
  void main(void) {
    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
  }
  </script>

  <script id="shader-vs" type="x-shader/x-vertex">
  attribute vec3 aVertexPosition;

  uniform mat4 uMVMatrix;
  uniform mat4 uPMatrix;

  void main(void) {
    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
  }
  </script>


  <script type="text/javascript">

  var gl;
  function initGL(canvas) {
    try {
      gl = canvas.getContext("experimental-webgl");
      gl.viewportWidth = canvas.width;
      gl.viewportHeight = canvas.height;
    } catch (e) {
    }
    if (!gl) {
      alert("Could not initialise WebGL, sorry :-(");
    }
  }


  function getShader(gl, id) {
  var shaderScript = document.getElementById(id);
  if (!shaderScript) {
  return null;
  }

  var str = "";
  var k = shaderScript.firstChild;
  while (k) {
  if (k.nodeType == 3) {
  str += k.textContent;
  }
  k = k.nextSibling;
  }

  var shader;
  if (shaderScript.type == "x-shader/x-fragment") {
  shader = gl.createShader(gl.FRAGMENT_SHADER);
  } else if (shaderScript.type == "x-shader/x-vertex") {
  shader = gl.createShader(gl.VERTEX_SHADER);
  } else {
  return null;
  }

  gl.shaderSource(shader, str);
  gl.compileShader(shader);

  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
  alert(gl.getShaderInfoLog(shader));
  return null;
  }

  return shader;
  }


  var shaderProgram;

  function initShaders() {
  var fragmentShader = getShader(gl, "shader-fs");
  var vertexShader = getShader(gl, "shader-vs");

  shaderProgram = gl.createProgram();
  gl.attachShader(shaderProgram, vertexShader);
  gl.attachShader(shaderProgram, fragmentShader);
  gl.linkProgram(shaderProgram);

  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
  alert("Could not initialise shaders");
  }

  gl.useProgram(shaderProgram);

  shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
  gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

  shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
  shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
  }


  var mvMatrix = mat4.create();
  var pMatrix = mat4.create();

  function setMatrixUniforms() {
    gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
    gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
  }
  
  let triangles = [];
  function makeTriangle(a, b, c) {
    let triangleVertexPositionBuffer;
    triangleVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
      a[0], a[1], a[2],
      b[0], b[1], b[2],
      c[0], c[1], c[2],
    ]), gl.STATIC_DRAW);
    triangleVertexPositionBuffer.itemSize = 3;
    triangleVertexPositionBuffer.numItems = 3;
    //
    triangles.push({vertexPositionBuffer:triangleVertexPositionBuffer});
  }
  
  let divCount = 0;  
  function initBuffers() {
    triangles = [];
    tetrahedron(
      [1, 0, 1/Math.sqrt(2)],
      [-1, 0, 1/Math.sqrt(2)],
      [0, 1, -1/Math.sqrt(2)],
      [0, -1, -1/Math.sqrt(2)], 
      divCount, 
    );
  }
  
  function normalize(value, _) {
    return value;
  }
  function mix(a, b, x) {
    return [a[0] * x + b[0] * (1-x), a[1] * x + b[1] * (1-x), a[2] * x + b[2] * (1-x)];
  }
  function tetrahedron(a, b, c, d, n) {
    divideTriangle(a, b, c, n);
    divideTriangle(d, c, b, n);
    divideTriangle(a, d, b, n);
    divideTriangle(a, c, d, n);
  }
  function divideTriangle(a, b, c, count) {
    if (count > 0) {
      let ab = normalize(mix(a, b, 0.5), true);
      let ac = normalize(mix(a, c, 0.5), true);
      let bc = normalize(mix(b, c, 0.5), true);
      divideTriangle(a, ab, ac, count - 1);
      divideTriangle(ab, b, bc, count - 1);
      divideTriangle(ab, bc, ac, count - 1);
    } else {
      makeTriangle(a, b, c);
    }
  }
  
  function add() {
    ++divCount;
    initBuffers();
  }
  
  function sub() {
    --divCount;
    if (divCount == -1) divCount = 0;
    initBuffers();
  }

  function degToRad(r) {
    return Math.PI * r / 180;
  }
  var r = 0;
  function drawScene() {
    gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
    mat4.identity(mvMatrix);
    mat4.translate(mvMatrix, [0.0, 0.0, -7.0]);
    
    for (let triangle of triangles) {
      let triangleVertexPositionBuffer = triangle.vertexPositionBuffer;
      gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);
      gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, triangleVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
      gl.drawArrays(gl.TRIANGLES, 0, triangleVertexPositionBuffer.numItems);
    }
    
    mat4.rotate(mvMatrix, degToRad(r), [0,1,0]);
    setMatrixUniforms();
  }

  function tick() {
    window.requestAnimationFrame(tick);
    drawScene();
    r += 1;    
  }

  function webGLStart() {
    var canvas = document.getElementById("lesson01-canvas");
    initGL(canvas);
    initShaders();
    initBuffers();

    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.enable(gl.DEPTH_TEST);

    tick();
  }


  </script>
  </head>
  <body onload="webGLStart();">
    <canvas id="lesson01-canvas" style="border: none;" width="500" height="500"></canvas>
    <button onclick="add();">Add</button>
    <button onclick="sub();">Sub</button>
  </body>
</html>
